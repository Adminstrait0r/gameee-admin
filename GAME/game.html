<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RPG Battle</title>
<style>
/* ... (keep all CSS styles the same as before) ... */
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
<div class="app">
    <!-- TOP BAR -->
    <div class="top-bar">
        <div class="profile">
            <div class="pfp" id="player-avatar">
                <i class="fas fa-user"></i>
            </div>
            <div class="profile-info">
                <div style="font-weight: 700;">HIGH SCORE: <span id="player-highscore">-</span></div>
                <div>NAME: <span id="player-name">-</span></div>
                <div>POWER: <span id="player-power">-</span></div>
            </div>
        </div>
        
        <div class="stage-display">
            <div class="stage-main" id="current-stage">STAGE -</div>
            <div class="stage-sub" id="stage-level">LEVEL -</div>
        </div>
        
        <div class="gold-display">
            <i class="fas fa-coins"></i> GOLD<br>
            <span id="gold-amount">-</span>
        </div>
    </div>

    <!-- BATTLE AREA -->
    <div class="battle-area">
        <div class="monster-header">
            <div class="monster-name" id="monster-name">-</div>
            <div class="monster-category" id="monster-category">-</div>
        </div>
        
        <div class="monster-hp-container">
            <div class="hp-bar">
                <div class="hp-fill" id="monster-hp-bar" style="width: 100%"></div>
            </div>
            <div class="hp-text" id="monster-hp-text">HP: - / -</div>
        </div>
        
        <div class="battle-grid">
            <!-- PLAYER PANEL -->
            <div class="player-panel">
                <div class="panel-box difficulty" id="difficulty">-</div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-damage">-</div>
                    <div class="stat-label">DAMAGE</div>
                </div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-defense">-</div>
                    <div class="stat-label">DEFENSE</div>
                </div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-crit">-</div>
                    <div class="stat-label">CRIT CHANCE</div>
                </div>
            </div>
            
            <!-- MONSTER DISPLAY -->
            <div class="monster-display">
                <div class="monster-image" id="monster-image">
                    <i class="fas fa-question"></i>
                </div>
            </div>
            
            <!-- TIMER -->
            <div class="timer-container">
                <div class="timer" id="timer">
                    <span id="timer-seconds">-</span>
                    <div class="timer-ring" id="timer-ring"></div>
                </div>
                <div class="timer-text" id="timer-text">SECONDS REMAINING</div>
            </div>
        </div>
    </div>

    <!-- QUESTION SECTION -->
    <div class="question-section">
        <div class="question-header">
            <div class="question-category" id="question-category">-</div>
            <div class="question-difficulty" id="question-difficulty">-</div>
        </div>
        <div class="question-box" id="question-text">
            -
        </div>
        <div class="question-image" id="question-image"></div>
    </div>

    <!-- ANSWERS -->
    <div class="answers-section" id="answers-container">
        <div class="answer-option answer-a" data-index="0">
            <div class="option-label">A</div>
            <div class="answer-text" id="answer-text-0">-</div>
            <div class="answer-image" id="answer-image-0"></div>
        </div>
        <div class="answer-option answer-b" data-index="1">
            <div class="option-label">B</div>
            <div class="answer-text" id="answer-text-1">-</div>
            <div class="answer-image" id="answer-image-1"></div>
        </div>
        <div class="answer-option answer-c" data-index="2">
            <div class="option-label">C</div>
            <div class="answer-text" id="answer-text-2">-</div>
            <div class="answer-image" id="answer-image-2"></div>
        </div>
        <div class="answer-option answer-d" data-index="3">
            <div class="option-label">D</div>
            <div class="answer-text" id="answer-text-3">-</div>
            <div class="answer-image" id="answer-image-3"></div>
        </div>
    </div>

    <!-- PLAYER HEALTH -->
    <div class="player-health-section">
        <div class="health-container">
            <div class="health-bar">
                <div class="health-fill" id="player-hp-bar" style="width: 100%"></div>
            </div>
            <div class="health-text" id="player-hp-text">HEALTH: - / -</div>
        </div>
        
        <div class="flasks">
            <div class="flask" id="health-flask" onclick="useHealthFlask()">
                <i class="fas fa-flask"></i>
                <div class="flask-count" id="flask-count">-</div>
            </div>
            <div class="flask" onclick="toggleCombatLog()" style="background: var(--blue);">
                <i class="fas fa-scroll"></i>
            </div>
        </div>
    </div>
</div>

<!-- COMBAT LOG -->
<div class="combat-log" id="combat-log">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h4 style="margin: 0;">Combat Log</h4>
        <button class="btn" onclick="clearCombatLog()" style="font-size: 10px; padding: 4px 8px;">Clear</button>
    </div>
    <div id="log-entries"></div>
</div>

<!-- RESULT MODAL -->
<div class="modal" id="result-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="result-title">-</h3>
            <button class="close-btn" onclick="closeResultModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div id="result-content">
                <div class="loading">-</div>
            </div>
        </div>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div class="modal" id="gameover-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--red);">GAME OVER</h3>
            <button class="close-btn" onclick="closeGameOverModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-skull-crossbones" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4>You have been defeated!</h4>
                <p id="gameover-details">-</p>
                <p id="gameover-gold">-</p>
                <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="returnToLobby()">
                        <i class="fas fa-home"></i> LOBBY
                    </button>
                    <button class="btn btn-success" onclick="restartRun()">
                        <i class="fas fa-redo"></i> RETRY
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- STAGE CLEAR MODAL -->
<div class="modal" id="stageclear-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--green);">STAGE CLEAR!</h3>
            <button class="close-btn" onclick="closeStageClearModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-trophy" style="font-size: 64px; color: var(--yellow); margin-bottom: 20px;"></i>
                <h4>Monster Defeated!</h4>
                <p id="stageclear-details">-</p>
                <p id="stageclear-reward">-</p>
                <p id="stageclear-streak">-</p>
                <div style="margin-top: 30px;">
                    <button class="btn btn-success" onclick="nextStage()">
                        <i class="fas fa-forward"></i> NEXT STAGE
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ERROR MODAL -->
<div class="modal" id="error-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--red);">ERROR</h3>
            <button class="close-btn" onclick="closeErrorModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-exclamation-triangle" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4 id="error-title">Game Setup Required</h4>
                <p id="error-message">No game data found. Please set up the game first.</p>
                <div style="margin-top: 30px;">
                    <button class="btn btn-primary" onclick="goToAdmin()">
                        <i class="fas fa-cog"></i> GO TO ADMIN PANEL
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
// Import Supabase client
import { supabase } from './supabase.js';

console.log('RPG Battle - Supabase client loaded');

// Game state
let gameState = {
    currentRun: null,
    playerStats: null,
    currentMonster: null,
    currentQuestion: null,
    questionOptions: [],
    selectedAnswer: null,
    timerInterval: null,
    timeLeft: 30,
    maxTime: 30,
    isAnswering: false,
    combatLog: [],
    healthFlasks: 3,
    streak: 0,
    goldEarned: 0,
    currentUser: null,
    monsterQuestions: [],      // All questions assigned to current monster
    currentQuestionIndex: 0    // Current question index in monsterQuestions array
};

// Initialize game
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Initializing RPG Battle...');
    
    // Load game data
    await loadGameData();
    
    // Setup event listeners
    setupEventListeners();
});

// Load game data from Supabase
async function loadGameData() {
    try {
        console.log('Step 1: Loading user...');
        
        // Get current user
        const { data: users, error: usersError } = await supabase
            .from('users')
            .select('*')
            .order('created_at', { ascending: true })
            .limit(1);
        
        if (usersError) {
            console.error('Error loading users:', usersError);
            showError('Database Error', 'Could not load user data. Please check database connection.');
            return;
        }
        
        if (!users || users.length === 0) {
            showError('No User Found', 'Please create a user in the admin panel first.');
            return;
        }
        
        gameState.currentUser = users[0];
        console.log('User loaded:', gameState.currentUser.username);
        
        // Update player info
        document.getElementById('player-name').textContent = gameState.currentUser.username || 'Player';
        document.getElementById('player-highscore').textContent = gameState.currentUser.highest_stage || 1;
        document.getElementById('gold-amount').textContent = gameState.currentUser.gold || 0;
        
        console.log('Step 2: Loading player stats...');
        
        // Get player stats
        const { data: stats, error: statsError } = await supabase
            .from('player_stats')
            .select('*')
            .eq('user_id', gameState.currentUser.id)
            .single();
        
        if (statsError) {
            console.error('Error loading player stats:', statsError);
            
            // Check if it's a "no rows returned" error
            if (statsError.code === 'PGRST116') {
                // No player stats found, create default stats
                console.log('No player stats found, creating default...');
                await createDefaultPlayerStats();
            } else {
                showError('Player Stats Error', 'Error loading player stats: ' + statsError.message);
                return;
            }
        } else if (stats) {
            gameState.playerStats = stats;
            console.log('Player stats loaded');
        }
        
        console.log('Step 3: Loading current run...');
        
        // Get current run - SIMPLIFIED QUERY without join
        const { data: runs, error: runsError } = await supabase
            .from('runs')
            .select('*')
            .eq('user_id', gameState.currentUser.id)
            .order('created_at', { ascending: false })
            .limit(1);
        
        if (runsError) {
            console.error('Error loading runs:', runsError);
            
            // Check if runs table exists
            if (runsError.message.includes('relation') && runsError.message.includes('does not exist')) {
                console.log('Runs table does not exist or has issues');
                showError('Database Setup Required', 'The runs table is not set up properly. Please use the admin panel to initialize the database.');
                return;
            }
            
            showError('Database Error', 'Could not load game data: ' + runsError.message);
            return;
        }
        
        if (runs && runs.length > 0) {
            gameState.currentRun = runs[0];
            console.log('Run loaded for stage:', gameState.currentRun.current_stage);
            
            // Load monster if available
            if (gameState.currentRun.current_monster) {
                console.log('Loading monster by ID:', gameState.currentRun.current_monster);
                await loadMonster(gameState.currentRun.current_monster);
            } else {
                // Get monster for current stage
                console.log('Loading monster for stage:', gameState.currentRun.current_stage);
                await loadMonsterForStage(gameState.currentRun.current_stage);
            }
            
            // Check if monsters exist
            if (!gameState.currentMonster) {
                console.log('No monster found, checking database...');
                
                // Check if any monsters exist
                const { data: monsterCheck, error: monsterCheckError } = await supabase
                    .from('monsters')
                    .select('id', { count: 'exact', head: true });
                
                if (monsterCheckError) {
                    console.error('Error checking monsters:', monsterCheckError);
                }
                
                showError('No Monsters', 'Please add monsters to the database in the admin panel.');
                return;
            }
            
            updateRunDisplay();
            
            // Load monster-specific questions
            await loadMonsterQuestions(gameState.currentMonster.id);
            
            // Load first question
            await loadQuestion();
            
            // Start the game timer
            startTimer();
            
        } else {
            // No active run, create one
            console.log('No active run found, creating new run...');
            await createNewRun();
        }
        
    } catch (error) {
        console.error('Error loading game data:', error);
        showError('Game Error', 'Failed to load game. Please try again. Error: ' + error.message);
    }
}

// Create default player stats
async function createDefaultPlayerStats() {
    try {
        const defaultStats = {
            user_id: gameState.currentUser.id,
            base_hp: 100,
            base_damage: 10,
            base_defense: 5,
            crit_chance: 0.05
        };
        
        const { data, error } = await supabase
            .from('player_stats')
            .insert([defaultStats])
            .select()
            .single();
        
        if (error) throw error;
        
        gameState.playerStats = data;
        console.log('Default player stats created');
        
    } catch (error) {
        console.error('Error creating default player stats:', error);
        showError('Player Stats Error', 'Could not create player stats: ' + error.message);
    }
}

// Create new run
async function createNewRun() {
    try {
        console.log('Creating new run...');
        
        // Check if monsters exist
        const { data: monsters, error: monstersError } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', 1)
            .limit(1);
        
        if (monstersError) {
            console.error('Error checking monsters:', monstersError);
            showError('Database Error', 'Could not check monsters: ' + monstersError.message);
            return;
        }
        
        if (!monsters || monsters.length === 0) {
            showError('No Monsters', 'Please add monsters to the database in the admin panel.');
            return;
        }
        
        const monster = monsters[0];
        const playerHP = gameState.playerStats?.base_hp || 100;
        
        console.log('Creating run with monster:', monster.name);
        
        // Create run
        const runData = {
            user_id: gameState.currentUser.id,
            current_stage: 1,
            current_monster: monster.id,
            player_hp: playerHP,
            monster_hp: monster.hp,
            streak: 0,
            started_at: new Date().toISOString()
        };
        
        console.log('Run data:', runData);
        
        const { data: run, error: runError } = await supabase
            .from('runs')
            .insert([runData])
            .select()
            .single();
        
        if (runError) {
            console.error('Error creating run:', runError);
            
            // Check if error is due to missing columns
            if (runError.message.includes('column')) {
                showError('Database Schema Error', 'The runs table is missing required columns. Please reset the database in the admin panel.');
                return;
            }
            
            throw runError;
        }
        
        gameState.currentRun = run;
        await loadMonster(monster.id);
        updateRunDisplay();
        
        // Load monster-specific questions
        await loadMonsterQuestions(monster.id);
        
        addToCombatLog('New run started!', 'info');
        
        // Load first question
        await loadQuestion();
        
        // Start timer
        startTimer();
        
    } catch (error) {
        console.error('Error creating new run:', error);
        showError('Run Creation Failed', 'Could not start new game. Please try again. Error: ' + error.message);
    }
}

// Load monster data
async function loadMonster(monsterId) {
    try {
        console.log('Loading monster with ID:', monsterId);
        
        const { data: monster, error } = await supabase
            .from('monsters')
            .select('*')
            .eq('id', monsterId)
            .single();
        
        if (error) {
            console.error('Error loading monster:', error);
            
            // If monster not found, try to get any monster
            if (error.code === 'PGRST116') {
                console.log('Monster not found, trying to get any monster...');
                const { data: anyMonster, error: anyError } = await supabase
                    .from('monsters')
                    .select('*')
                    .limit(1)
                    .single();
                
                if (anyError) {
                    console.error('Error loading any monster:', anyError);
                    gameState.currentMonster = null;
                    return;
                }
                
                gameState.currentMonster = anyMonster;
            } else {
                gameState.currentMonster = null;
            }
        } else {
            gameState.currentMonster = monster;
        }
        
        if (gameState.currentMonster) {
            console.log('Monster loaded:', gameState.currentMonster.name);
            updateMonsterDisplay();
        }
        
    } catch (error) {
        console.error('Error in loadMonster:', error);
        gameState.currentMonster = null;
    }
}

// Load monster-specific questions
async function loadMonsterQuestions(monsterId) {
    try {
        console.log('Loading questions for monster:', monsterId);
        
        // Try to get questions from monster_questions table
        try {
            const { data: monsterQuestions, error } = await supabase
                .from('monster_questions')
                .select(`
                    question_order,
                    questions (*)
                `)
                .eq('monster_id', monsterId)
                .order('question_order', { ascending: true });
            
            if (error) {
                console.error('Error loading monster_questions:', error);
                
                // If table doesn't exist, use fallback
                if (error.message.includes('relation') && error.message.includes('does not exist')) {
                    console.log('monster_questions table does not exist, using fallback');
                    gameState.monsterQuestions = [];
                    return;
                }
                throw error;
            }
            
            if (monsterQuestions && monsterQuestions.length > 0) {
                // Extract the questions from the result
                gameState.monsterQuestions = monsterQuestions.map(mq => ({
                    ...mq.questions,
                    question_order: mq.question_order
                }));
                gameState.currentQuestionIndex = 0;
                console.log(`Loaded ${gameState.monsterQuestions.length} monster-specific questions`);
            } else {
                // No specific questions assigned
                console.log('No specific questions assigned to monster');
                gameState.monsterQuestions = [];
            }
            
        } catch (tableError) {
            console.error('Error with monster_questions table:', tableError);
            gameState.monsterQuestions = [];
        }
        
    } catch (error) {
        console.error('Error in loadMonsterQuestions:', error);
        gameState.monsterQuestions = [];
    }
}

// Load monster for current stage
async function loadMonsterForStage(stage) {
    try {
        console.log('Loading monster for stage:', stage);
        
        const { data: monsters, error } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', stage)
            .limit(1);
        
        if (error) {
            console.error('Error loading monster for stage:', error);
            return;
        }
        
        if (monsters && monsters.length > 0) {
            gameState.currentMonster = monsters[0];
            updateMonsterDisplay();
            
            // Load monster-specific questions
            await loadMonsterQuestions(gameState.currentMonster.id);
        }
        
    } catch (error) {
        console.error('Error in loadMonsterForStage:', error);
    }
}

// Load question from database
async function loadQuestion() {
    try {
        // Reset selection
        gameState.selectedAnswer = null;
        gameState.isAnswering = false;
        
        // Clear previous selections
        document.querySelectorAll('.answer-option').forEach(option => {
            option.classList.remove('selected', 'correct', 'incorrect');
        });
        
        let question = null;
        
        // Check if we have monster-specific questions
        if (gameState.monsterQuestions && gameState.monsterQuestions.length > 0) {
            // Use monster-specific questions in order
            question = gameState.monsterQuestions[gameState.currentQuestionIndex];
            
            // Move to next question (loop back if at end)
            gameState.currentQuestionIndex = (gameState.currentQuestionIndex + 1) % gameState.monsterQuestions.length;
            
            console.log(`Using monster-specific question ${gameState.currentQuestionIndex}/${gameState.monsterQuestions.length}`);
            
        } else {
            // Fallback: Get random question
            console.log('Using fallback: random question');
            
            // Check if questions exist
            const { data: questionsCount, error: countError } = await supabase
                .from('questions')
                .select('*', { count: 'exact', head: true });
            
            if (countError) {
                console.error('Error checking questions:', countError);
                throw countError;
            }
            
            if (!questionsCount || questionsCount === 0) {
                showError('No Questions', 'Please add questions to the database in the admin panel.');
                return;
            }
            
            // Get all questions
            const { data: allQuestions, error: allError } = await supabase
                .from('questions')
                .select('*');
            
            if (allError) throw allError;
            
            if (!allQuestions || allQuestions.length === 0) {
                addToCombatLog('No questions available!', 'error');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * allQuestions.length);
            question = allQuestions[randomIndex];
        }
        
        if (!question) {
            addToCombatLog('No question available!', 'error');
            return;
        }
        
        gameState.currentQuestion = question;
        
        // Get question options
        const { data: options, error: optionsError } = await supabase
            .from('question_options')
            .select('*')
            .eq('question_id', gameState.currentQuestion.id);
        
        if (optionsError) {
            console.error('Error loading question options:', optionsError);
            
            // If no options found, create some default options
            if (optionsError.code === 'PGRST116') {
                console.log('No options found for question, using defaults');
                gameState.questionOptions = [
                    { option_text: 'Option A', is_correct: false },
                    { option_text: 'Option B', is_correct: true },
                    { option_text: 'Option C', is_correct: false },
                    { option_text: 'Option D', is_correct: false }
                ];
            } else {
                throw optionsError;
            }
        } else {
            gameState.questionOptions = options || [];
        }
        
        // Check if we have enough options
        if (gameState.questionOptions.length < 2) {
            addToCombatLog('Question has insufficient options!', 'error');
            return;
        }
        
        // Shuffle options to randomize positions (keep track of correct answer)
        shuffleOptions();
        
        // Update display
        updateQuestionDisplay();
        
        // Set timer based on question
        gameState.maxTime = gameState.currentQuestion.timer_seconds || 30;
        gameState.timeLeft = gameState.maxTime;
        updateTimer();
        
        // Reset timer ring
        document.getElementById('timer-ring').style.transform = 'rotate(0deg)';
        
        addToCombatLog('New question loaded: ' + gameState.currentQuestion.category, 'info');
        
    } catch (error) {
        console.error('Error loading question:', error);
        addToCombatLog('Failed to load question: ' + error.message, 'error');
        
        // Use a fallback question if everything fails
        useFallbackQuestion();
    }
}

// Use fallback question when database queries fail
function useFallbackQuestion() {
    console.log('Using fallback question');
    
    gameState.currentQuestion = {
        id: 'fallback',
        question_text: 'What is 2 + 2?',
        category: 'MATH',
        difficulty: 'EASY',
        timer_seconds: 30
    };
    
    gameState.questionOptions = [
        { id: '1', option_text: '3', is_correct: false },
        { id: '2', option_text: '4', is_correct: true },
        { id: '3', option_text: '5', is_correct: false },
        { id: '4', option_text: '6', is_correct: false }
    ];
    
    updateQuestionDisplay();
    gameState.maxTime = 30;
    gameState.timeLeft = 30;
    updateTimer();
    
    addToCombatLog('Using fallback question', 'info');
}

// Shuffle question options while keeping track of correct answer
function shuffleOptions() {
    if (!gameState.questionOptions || gameState.questionOptions.length < 2) return;
    
    // Create array of indices
    const indices = Array.from({ length: gameState.questionOptions.length }, (_, i) => i);
    
    // Fisher-Yates shuffle
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    
    // Reorder options based on shuffled indices
    const shuffledOptions = indices.map(i => gameState.questionOptions[i]);
    gameState.questionOptions = shuffledOptions;
}

// Update player stats display
function updatePlayerStats() {
    if (!gameState.playerStats) {
        // Use default values
        document.getElementById('player-damage').textContent = '10';
        document.getElementById('player-defense').textContent = '5';
        document.getElementById('player-crit').textContent = '5.0%';
        document.getElementById('player-power').textContent = '20';
        return;
    }
    
    const baseDamage = gameState.playerStats.base_damage || 10;
    const baseDefense = gameState.playerStats.base_defense || 5;
    const critChance = gameState.playerStats.crit_chance || 0.05;
    
    document.getElementById('player-damage').textContent = baseDamage;
    document.getElementById('player-defense').textContent = baseDefense;
    document.getElementById('player-crit').textContent = `${(critChance * 100).toFixed(1)}%`;
    
    // Calculate power level
    const power = baseDamage + baseDefense + (critChance * 100);
    document.getElementById('player-power').textContent = Math.round(power);
}

// Update run display
function updateRunDisplay() {
    if (!gameState.currentRun) {
        document.getElementById('current-stage').textContent = 'STAGE 1';
        document.getElementById('stage-level').textContent = 'LEVEL 1';
        return;
    }
    
    document.getElementById('current-stage').textContent = `STAGE ${gameState.currentRun.current_stage || 1}`;
    document.getElementById('stage-level').textContent = `LEVEL ${gameState.currentRun.current_stage || 1}`;
    
    // Update player HP
    const playerHP = gameState.currentRun.player_hp || 100;
    const maxHP = gameState.playerStats?.base_hp || 100;
    const hpPercent = (playerHP / maxHP) * 100;
    
    document.getElementById('player-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('player-hp-text').textContent = `HEALTH: ${playerHP} / ${maxHP}`;
    
    // Update streak
    gameState.streak = gameState.currentRun.streak || 0;
    
    // Update player stats
    updatePlayerStats();
}

// Update monster display
function updateMonsterDisplay() {
    if (!gameState.currentMonster) {
        document.getElementById('monster-name').textContent = 'Unknown Monster';
        document.getElementById('monster-category').textContent = 'MONSTER';
        document.getElementById('monster-hp-bar').style.width = '100%';
        document.getElementById('monster-hp-text').textContent = 'HP: 100 / 100';
        document.getElementById('difficulty').textContent = 'EASY';
        
        const monsterImage = document.getElementById('monster-image');
        monsterImage.innerHTML = '<i class="fas fa-dragon"></i>';
        return;
    }
    
    document.getElementById('monster-name').textContent = gameState.currentMonster.name;
    document.getElementById('monster-category').textContent = gameState.currentMonster.category || 'MONSTER';
    
    // Update monster HP
    const monsterHP = gameState.currentRun?.monster_hp || gameState.currentMonster.hp || 100;
    const maxHP = gameState.currentMonster.hp || 100;
    const hpPercent = (monsterHP / maxHP) * 100;
    
    document.getElementById('monster-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('monster-hp-text').textContent = `HP: ${monsterHP} / ${maxHP}`;
    
    // Update difficulty
    const stage = gameState.currentRun?.current_stage || 1;
    const difficulty = stage <= 3 ? 'EASY' : stage <= 6 ? 'MEDIUM' : stage <= 10 ? 'HARD' : 'EXPERT';
    document.getElementById('difficulty').textContent = difficulty;
    
    // Update monster image
    const monsterImage = document.getElementById('monster-image');
    if (gameState.currentMonster.image_url) {
        monsterImage.innerHTML = `<img src="${gameState.currentMonster.image_url}" alt="${gameState.currentMonster.name}" onerror="this.parentElement.innerHTML='<i class=\\'fas fa-dragon\\'></i>'">`;
    } else {
        monsterImage.innerHTML = '<i class="fas fa-dragon"></i>';
    }
}

// Update question display
function updateQuestionDisplay() {
    if (!gameState.currentQuestion) return;
    
    document.getElementById('question-text').textContent = gameState.currentQuestion.question_text;
    document.getElementById('question-category').textContent = gameState.currentQuestion.category || 'GENERAL';
    document.getElementById('question-difficulty').textContent = gameState.currentQuestion.difficulty || 'MEDIUM';
    
    // Update question image
    const questionImage = document.getElementById('question-image');
    if (gameState.currentQuestion.image_url) {
        questionImage.src = gameState.currentQuestion.image_url;
        questionImage.alt = gameState.currentQuestion.question_text;
        questionImage.classList.add('show');
    } else {
        questionImage.classList.remove('show');
    }
    
    // Update answer options (only show up to 4 options)
    for (let i = 0; i < 4; i++) {
        const option = gameState.questionOptions[i];
        const answerText = document.getElementById(`answer-text-${i}`);
        const answerImage = document.getElementById(`answer-image-${i}`);
        const answerOption = document.querySelector(`.answer-option[data-index="${i}"]`);
        
        if (option) {
            answerText.textContent = option.option_text;
            
            if (option.image_url) {
                answerImage.src = option.image_url;
                answerImage.alt = option.option_text;
                answerImage.classList.add('show');
            } else {
                answerImage.classList.remove('show');
            }
            
            answerOption.style.display = 'flex';
        } else {
            answerOption.style.display = 'none';
        }
    }
}

// Setup event listeners
function setupEventListeners() {
    // Answer selection
    document.querySelectorAll('.answer-option').forEach(option => {
        option.addEventListener('click', function() {
            if (gameState.isAnswering) return;
            
            const index = parseInt(this.getAttribute('data-index'));
            selectAnswer(index);
        });
    });
}

// Select answer
function selectAnswer(index) {
    if (gameState.isAnswering) return;
    
    // Clear previous selection
    document.querySelectorAll('.answer-option').forEach(option => {
        option.classList.remove('selected');
    });
    
    // Mark selected
    const selectedOption = document.querySelector(`.answer-option[data-index="${index}"]`);
    selectedOption.classList.add('selected');
    gameState.selectedAnswer = index;
    gameState.isAnswering = true;
    
    // Clear timer
    clearInterval(gameState.timerInterval);
    
    // Check answer
    checkAnswer(index);
}

// Check if answer is correct
async function checkAnswer(selectedIndex) {
    const option = gameState.questionOptions[selectedIndex];
    const isCorrect = option?.is_correct || false;
    
    // Mark correct/incorrect
    document.querySelectorAll('.answer-option').forEach(optionEl => {
        const optionIndex = parseInt(optionEl.getAttribute('data-index'));
        const optionData = gameState.questionOptions[optionIndex];
        
        if (optionData?.is_correct) {
            optionEl.classList.add('correct');
        } else if (optionIndex === selectedIndex) {
            optionEl.classList.add('incorrect');
        }
    });
    
    // Process combat
    await processCombat(isCorrect);
    
    // Show result
    showResult(isCorrect, option?.option_text);
}

// Process combat based on answer
async function processCombat(isCorrect) {
    try {
        if (!gameState.currentRun || !gameState.currentMonster) return;
        
        let damageToMonster = 0;
        let damageToPlayer = 0;
        let goldEarned = 0;
        
        if (isCorrect) {
            // Player hits monster
            const baseDamage = gameState.playerStats?.base_damage || 10;
            const critChance = gameState.playerStats?.crit_chance || 0.05;
            const isCrit = Math.random() < critChance;
            
            damageToMonster = baseDamage;
            
            // Apply crit
            if (isCrit) {
                damageToMonster *= 2;
                addToCombatLog(`CRITICAL HIT! ${damageToMonster} damage!`, 'crit');
            } else {
                addToCombatLog(`Hit monster for ${damageToMonster} damage`, 'damage');
            }
            
            // Apply monster defense
            const monsterDefense = gameState.currentMonster.defense || 0;
            damageToMonster = Math.max(1, damageToMonster - monsterDefense);
            
            // Update monster HP
            let newMonsterHP = gameState.currentRun.monster_hp - damageToMonster;
            if (newMonsterHP < 0) newMonsterHP = 0;
            
            // Monster attacks player (reduced damage on correct answer)
            const monsterDamage = Math.floor((gameState.currentMonster.damage || 10) * 0.3);
            const playerDefense = gameState.playerStats?.base_defense || 5;
            damageToPlayer = Math.max(1, monsterDamage - playerDefense);
            
            addToCombatLog(`Monster hits back for ${damageToPlayer} damage`, 'damage');
            
            // Update player HP
            let newPlayerHP = gameState.currentRun.player_hp - damageToPlayer;
            
            // Gold reward - use monster's gold_reward field
            goldEarned = gameState.currentMonster.gold_reward || Math.floor(gameState.currentMonster.stage * 10);
            gameState.goldEarned += goldEarned;
            
            // Increase streak
            gameState.streak++;
            
            // Update run in database
            const { error: updateError } = await supabase
                .from('runs')
                .update({
                    monster_hp: newMonsterHP,
                    player_hp: newPlayerHP,
                    streak: gameState.streak
                })
                .eq('id', gameState.currentRun.id);
            
            if (updateError) {
                console.error('Error updating run:', updateError);
                // Continue with local update even if database fails
            }
            
            // Update local state
            gameState.currentRun.monster_hp = newMonsterHP;
            gameState.currentRun.player_hp = newPlayerHP;
            gameState.currentRun.streak = gameState.streak;
            
            // Check if monster is defeated
            if (newMonsterHP <= 0) {
                setTimeout(() => {
                    showStageClear(goldEarned);
                }, 1500);
            } else {
                setTimeout(() => {
                    loadQuestion();
                    startTimer();
                }, 2000);
            }
            
        } else {
            // Wrong answer - monster hits harder
            const monsterDamage = gameState.currentMonster.damage || 10;
            const playerDefense = gameState.playerStats?.base_defense || 5;
            damageToPlayer = Math.max(5, monsterDamage - playerDefense);
            
            addToCombatLog(`Wrong answer! Monster hits for ${damageToPlayer} damage`, 'damage');
            
            // Reset streak
            gameState.streak = 0;
            
            // Update player HP
            let newPlayerHP = gameState.currentRun.player_hp - damageToPlayer;
            
            // Update run in database
            const { error: updateError } = await supabase
                .from('runs')
                .update({
                    player_hp: newPlayerHP,
                    streak: 0
                })
                .eq('id', gameState.currentRun.id);
            
            if (updateError) {
                console.error('Error updating run:', updateError);
                // Continue with local update even if database fails
            }
            
            // Update local state
            gameState.currentRun.player_hp = newPlayerHP;
            gameState.currentRun.streak = 0;
            
            // Check if player is dead
            if (newPlayerHP <= 0) {
                setTimeout(() => {
                    showGameOver();
                }, 1500);
            } else {
                setTimeout(() => {
                    loadQuestion();
                    startTimer();
                }, 2000);
            }
        }
        
        // Update UI
        updateRunDisplay();
        updateMonsterDisplay();
        
    } catch (error) {
        console.error('Error processing combat:', error);
        addToCombatLog('Combat error: ' + error.message, 'error');
    }
}

// Start timer
function startTimer() {
    // Clear existing timer
    clearInterval(gameState.timerInterval);
    
    // Reset time
    gameState.timeLeft = gameState.maxTime;
    updateTimer();
    
    // Start countdown
    gameState.timerInterval = setInterval(() => {
        gameState.timeLeft--;
        updateTimer();
        
        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timerInterval);
            timeOut();
        }
    }, 1000);
}

// Update timer display
function updateTimer() {
    document.getElementById('timer-seconds').textContent = gameState.timeLeft;
    
    // Update timer ring
    const progress = (gameState.timeLeft / gameState.maxTime) * 360;
    document.getElementById('timer-ring').style.transform = `rotate(${progress}deg)`;
    
    // Update text color based on time
    if (gameState.timeLeft <= 10) {
        document.getElementById('timer-seconds').style.color = 'var(--red)';
    } else if (gameState.timeLeft <= 20) {
        document.getElementById('timer-seconds').style.color = 'var(--orange)';
    } else {
        document.getElementById('timer-seconds').style.color = 'var(--accent)';
    }
}

// Time out handler
function timeOut() {
    if (gameState.isAnswering) return;
    
    addToCombatLog('Time ran out!', 'info');
    
    // Process as wrong answer
    const optionsCount = Math.min(4, gameState.questionOptions.length);
    if (optionsCount > 0) {
        const randomAnswer = Math.floor(Math.random() * optionsCount);
        selectAnswer(randomAnswer);
    } else {
        // No options available, treat as wrong answer
        processCombat(false);
    }
}

// Show result
function showResult(isCorrect, answerText) {
    const modal = document.getElementById('result-modal');
    const title = document.getElementById('result-title');
    const content = document.getElementById('result-content');
    
    if (isCorrect) {
        title.textContent = 'CORRECT!';
        title.style.color = 'var(--green)';
        content.innerHTML = `
            <div style="text-align: center;">
                <i class="fas fa-check-circle" style="font-size: 64px; color: var(--green); margin-bottom: 20px;"></i>
                <h4>Well done!</h4>
                <p>Your answer: <strong>${answerText || 'Correct'}</strong></p>
                <p>Streak: <strong>${gameState.streak}</strong></p>
            </div>
        `;
    } else {
        title.textContent = 'WRONG!';
        title.style.color = 'var(--red)';
        content.innerHTML = `
            <div style="text-align: center;">
                <i class="fas fa-times-circle" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4>Incorrect answer</h4>
                <p>Your answer: <strong>${answerText || 'Wrong'}</strong></p>
                <p>The correct answer was highlighted.</p>
                <p>Streak lost!</p>
            </div>
        `;
    }
    
    modal.classList.add('active');
}

// Close result modal
function closeResultModal() {
    document.getElementById('result-modal').classList.remove('active');
}

// Show stage clear
function showStageClear(goldEarned) {
    const modal = document.getElementById('stageclear-modal');
    
    document.getElementById('stageclear-details').textContent = 
        `Stage ${gameState.currentRun.current_stage} cleared!`;
    document.getElementById('stageclear-reward').textContent = 
        `Reward: ${goldEarned} Gold`;
    document.getElementById('stageclear-streak').textContent = 
        `Streak: ${gameState.streak}`;
    
    modal.classList.add('active');
}

// Close stage clear modal
function closeStageClearModal() {
    document.getElementById('stageclear-modal').classList.remove('active');
}

// Show game over
async function showGameOver() {
    try {
        // Update user gold
        const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
        
        await supabase
            .from('users')
            .update({ 
                gold: newGold,
                highest_stage: Math.max(gameState.currentUser.highest_stage || 0, gameState.currentRun.current_stage)
            })
            .eq('id', gameState.currentUser.id);
        
        // Delete the run
        await supabase
            .from('runs')
            .delete()
            .eq('id', gameState.currentRun.id);
        
        const modal = document.getElementById('gameover-modal');
        
        document.getElementById('gameover-details').textContent = 
            `Stage reached: ${gameState.currentRun.current_stage}`;
        document.getElementById('gameover-gold').textContent = 
            `Gold earned: ${gameState.goldEarned}`;
        
        modal.classList.add('active');
        
    } catch (error) {
        console.error('Error in game over:', error);
        
        // Show modal even if database update fails
        const modal = document.getElementById('gameover-modal');
        document.getElementById('gameover-details').textContent = 
            `Stage reached: ${gameState.currentRun.current_stage}`;
        document.getElementById('gameover-gold').textContent = 
            `Gold earned: ${gameState.goldEarned}`;
        
        modal.classList.add('active');
    }
}

// Close game over modal
function closeGameOverModal() {
    document.getElementById('gameover-modal').classList.remove('active');
}

// Show error modal
function showError(title, message) {
    document.getElementById('error-title').textContent = title;
    document.getElementById('error-message').textContent = message;
    document.getElementById('error-modal').classList.add('active');
}

// Close error modal
function closeErrorModal() {
    document.getElementById('error-modal').classList.remove('active');
}

// Go to admin panel
function goToAdmin() {
    window.location.href = 'adminside.html';
}

// Next stage
async function nextStage() {
    try {
        const nextStage = gameState.currentRun.current_stage + 1;
        
        // Get monster for next stage
        const { data: monsters, error: monstersError } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', nextStage)
            .limit(1);
        
        if (monstersError) {
            console.error('Error loading monsters for next stage:', monstersError);
            
            // If no monster for next stage, show victory
            if (monstersError.code === 'PGRST116' || monstersError.message.includes('relation')) {
                // Victory!
                addToCombatLog('No more monsters! You win!', 'info');
                
                // Update user with final gold
                const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
                
                try {
                    await supabase
                        .from('users')
                        .update({ 
                            gold: newGold,
                            highest_stage: Math.max(gameState.currentUser.highest_stage || 0, gameState.currentRun.current_stage)
                        })
                        .eq('id', gameState.currentUser.id);
                    
                    // Delete run
                    await supabase
                        .from('runs')
                        .delete()
                        .eq('id', gameState.currentRun.id);
                } catch (dbError) {
                    console.error('Database error in victory:', dbError);
                }
                
                alert('Congratulations! You have completed all stages!');
                window.location.href = 'lobby.html';
                return;
            }
            throw monstersError;
        }
        
        if (!monsters || monsters.length === 0) {
            // No more stages - victory!
            addToCombatLog('No more monsters! You win!', 'info');
            
            // Update user with final gold
            const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
            
            await supabase
                .from('users')
                .update({ 
                    gold: newGold,
                    highest_stage: Math.max(gameState.currentUser.highest_stage || 0, gameState.currentRun.current_stage)
                })
                .eq('id', gameState.currentUser.id);
            
            // Delete run
            await supabase
                .from('runs')
                .delete()
                .eq('id', gameState.currentRun.id);
            
            alert('Congratulations! You have completed all stages!');
            window.location.href = 'lobby.html';
            return;
        }
        
        const monster = monsters[0];
        
        // Update run to next stage
        const { error: updateError } = await supabase
            .from('runs')
            .update({
                current_stage: nextStage,
                current_monster: monster.id,
                monster_hp: monster.hp
            })
            .eq('id', gameState.currentRun.id);
        
        if (updateError) {
            console.error('Error updating run for next stage:', updateError);
            // Continue with local update
        }
        
        // Update local state
        gameState.currentRun.current_stage = nextStage;
        gameState.currentRun.current_monster = monster.id;
        gameState.currentRun.monster_hp = monster.hp;
        
        // Update gold in user
        const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
        
        try {
            await supabase
                .from('users')
                .update({ gold: newGold })
                .eq('id', gameState.currentUser.id);
            
            document.getElementById('gold-amount').textContent = newGold;
            gameState.currentUser.gold = newGold;
            gameState.goldEarned = 0;
        } catch (goldError) {
            console.error('Error updating gold:', goldError);
        }
        
        // Reset question cycling
        gameState.currentQuestionIndex = 0;
        
        closeStageClearModal();
        await loadMonster(monster.id);
        await loadMonsterQuestions(monster.id);
        await loadQuestion();
        startTimer();
        
        addToCombatLog(`Advanced to stage ${nextStage}!`, 'info');
        
    } catch (error) {
        console.error('Error advancing to next stage:', error);
        addToCombatLog('Failed to advance: ' + error.message, 'error');
    }
}

// Return to lobby
function returnToLobby() {
    closeGameOverModal();
    window.location.href = 'lobby.html';
}

// Restart run
async function restartRun() {
    try {
        // Delete current run
        await supabase
            .from('runs')
            .delete()
            .eq('id', gameState.currentRun.id);
        
        closeGameOverModal();
        await createNewRun();
        
    } catch (error) {
        console.error('Error restarting run:', error);
    }
}

// Use health flask
function useHealthFlask() {
    if (gameState.healthFlasks <= 0 || !gameState.currentRun) return;
    
    if (gameState.currentRun.player_hp >= (gameState.playerStats?.base_hp || 100)) {
        addToCombatLog('Already at full health!', 'info');
        return;
    }
    
    gameState.healthFlasks--;
    
    // Heal 50% of max HP
    const maxHP = gameState.playerStats?.base_hp || 100;
    const healAmount = Math.floor(maxHP * 0.5);
    const newHP = Math.min(maxHP, gameState.currentRun.player_hp + healAmount);
    
    // Update run
    supabase
        .from('runs')
        .update({ player_hp: newHP })
        .eq('id', gameState.currentRun.id)
        .then(() => {
            gameState.currentRun.player_hp = newHP;
            updateRunDisplay();
            addToCombatLog(`Used health flask! Healed ${healAmount} HP`, 'heal');
            
            // Update flask count
            document.getElementById('flask-count').textContent = gameState.healthFlasks;
            
            if (gameState.healthFlasks <= 0) {
                document.getElementById('health-flask').classList.add('disabled');
            }
        })
        .catch(error => {
            console.error('Error using health flask:', error);
            addToCombatLog('Failed to use health flask', 'error');
        });
}

// Toggle combat log
function toggleCombatLog() {
    const log = document.getElementById('combat-log');
    log.classList.toggle('show');
}

// Clear combat log
function clearCombatLog() {
    gameState.combatLog = [];
    document.getElementById('log-entries').innerHTML = '';
}

// Add to combat log
function addToCombatLog(message, type = 'info') {
    gameState.combatLog.push({ message, type, timestamp: new Date() });
    
    // Keep only last 10 entries
    if (gameState.combatLog.length > 10) {
        gameState.combatLog.shift();
    }
    
    // Update display
    const logEntries = document.getElementById('log-entries');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}] ${message}`;
    
    logEntries.appendChild(entry);
    logEntries.scrollTop = logEntries.scrollHeight;
}

// Initialize health flask count
function initializeFlasks() {
    document.getElementById('flask-count').textContent = gameState.healthFlasks;
    if (gameState.healthFlasks <= 0) {
        document.getElementById('health-flask').classList.add('disabled');
    }
}

// Make functions globally available
window.useHealthFlask = useHealthFlask;
window.toggleCombatLog = toggleCombatLog;
window.clearCombatLog = clearCombatLog;
window.closeResultModal = closeResultModal;
window.closeStageClearModal = closeStageClearModal;
window.closeGameOverModal = closeGameOverModal;
window.returnToLobby = returnToLobby;
window.restartRun = restartRun;
window.nextStage = nextStage;
window.goToAdmin = goToAdmin;
window.closeErrorModal = closeErrorModal;

// Initialize flasks
initializeFlasks();
</script>
</body>
</html>