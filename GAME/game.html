<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RPG Battle</title>
<style>
:root {
    --bg-main: #f2efe6;
    --bg-panel: #e8e3d6;
    --border: #2b2b2b;
    --accent: #111;
    --tab-active: #d6c9a8;
    --tab-inactive: #e8e3d6;
    --green: #00b85c;
    --light-green: #c8ff7a;
    --bright-green: #b6ff5c;
    --yellow: #ffd84d;
    --red: #ff4d4d;
    --blue: #5c7cfa;
    --purple: #7e57c2;
    --cyan: #0097a7;
    --orange: #ffb74d;
}

* {
    box-sizing: border-box;
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
}

body {
    margin: 0;
    background: #333;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 16px;
}

.app {
    width: 100%;
    max-width: 1000px;
    background: var(--bg-main);
    border: 3px solid var(--border);
    min-height: 700px;
}

/* TOP BAR */
.top-bar {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 12px;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 3px solid var(--border);
    background: var(--bg-panel);
}

.profile {
    display: flex;
    align-items: center;
    gap: 12px;
}

.pfp {
    width: 50px;
    height: 50px;
    background: var(--yellow);
    border: 2px solid var(--border);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 12px;
}

.pfp img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.profile-info {
    font-size: 12px;
    line-height: 1.5;
    font-weight: 600;
}

.stage-display {
    justify-self: center;
    background: var(--cyan);
    padding: 10px 20px;
    border: 2px solid var(--border);
    text-align: center;
    font-weight: bold;
}

.stage-main {
    font-size: 16px;
    color: white;
}

.stage-sub {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.9);
}

.gold-display {
    background: var(--yellow);
    padding: 10px 20px;
    border: 2px solid var(--border);
    text-align: center;
    font-weight: bold;
    justify-self: end;
}

/* BATTLE AREA */
.battle-area {
    background: var(--cyan);
    padding: 20px;
    border-bottom: 3px solid var(--border);
}

.monster-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    background: rgba(0, 0, 0, 0.1);
    padding: 10px 15px;
    border: 2px solid var(--border);
}

.monster-name {
    font-size: 18px;
    font-weight: 700;
    color: white;
}

.monster-category {
    background: var(--purple);
    color: white;
    padding: 5px 10px;
    border: 2px solid var(--border);
    font-size: 12px;
    font-weight: 600;
}

.monster-hp-container {
    background: rgba(0, 0, 0, 0.2);
    border: 2px solid var(--border);
    padding: 10px;
    margin-bottom: 15px;
}

.hp-bar {
    height: 20px;
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid var(--border);
    overflow: hidden;
    margin-bottom: 8px;
}

.hp-fill {
    height: 100%;
    background: var(--red);
    transition: width 0.5s ease;
}

.hp-text {
    color: white;
    text-align: center;
    font-weight: 600;
    font-size: 14px;
}

/* BATTLE GRID */
.battle-grid {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    gap: 15px;
    align-items: center;
}

/* PLAYER PANEL */
.player-panel {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.panel-box {
    background: var(--light-green);
    border: 2px solid var(--border);
    padding: 15px;
    text-align: center;
    font-weight: bold;
}

.difficulty {
    background: var(--red);
    color: white;
}

.player-stat {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.stat-value {
    font-size: 24px;
    color: var(--accent);
}

.stat-label {
    font-size: 12px;
    color: var(--accent);
    opacity: 0.8;
}

/* TIMER */
.timer-container {
    justify-self: center;
}

.timer {
    width: 100px;
    height: 100px;
    background: var(--yellow);
    border: 3px solid var(--border);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 24px;
    color: var(--accent);
    position: relative;
}

.timer-text {
    font-size: 12px;
    position: absolute;
    bottom: -20px;
    width: 100%;
    text-align: center;
    color: white;
    font-weight: 600;
}

.timer-ring {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 3px solid transparent;
    border-top-color: var(--red);
    border-radius: 50%;
}

/* MONSTER DISPLAY */
.monster-display {
    background: var(--bg-main);
    border: 3px solid var(--border);
    height: 250px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.monster-image {
    width: 200px;
    height: 200px;
    background: var(--purple);
    border: 3px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 64px;
    color: white;
}

.monster-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* QUESTION SECTION */
.question-section {
    padding: 20px;
    border-bottom: 3px solid var(--border);
}

.question-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.question-category {
    background: var(--blue);
    color: white;
    padding: 8px 15px;
    border: 2px solid var(--border);
    font-weight: 600;
    font-size: 14px;
}

.question-difficulty {
    background: var(--orange);
    color: var(--accent);
    padding: 8px 15px;
    border: 2px solid var(--border);
    font-weight: 600;
    font-size: 14px;
}

.question-box {
    background: var(--blue);
    border: 3px solid var(--border);
    padding: 25px;
    color: white;
    font-weight: 600;
    font-size: 18px;
    text-align: center;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.question-image {
    max-width: 200px;
    max-height: 150px;
    margin: 15px auto;
    border: 2px solid var(--border);
    display: none;
}

.question-image.show {
    display: block;
}

/* ANSWERS */
.answers-section {
    padding: 20px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.answer-option {
    border: 3px solid var(--border);
    padding: 20px;
    font-weight: bold;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    min-height: 120px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.answer-option:hover {
    transform: translateY(-3px);
}

.answer-text {
    font-size: 16px;
    z-index: 2;
}

.answer-image {
    max-width: 80px;
    max-height: 80px;
    border: 2px solid var(--border);
    display: none;
}

.answer-image.show {
    display: block;
}

.option-label {
    position: absolute;
    top: 8px;
    left: 8px;
    background: var(--accent);
    color: white;
    width: 30px;
    height: 30px;
    border: 2px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
}

.answer-a { background: var(--light-green); }
.answer-b { background: #7ed957; }
.answer-c { background: #00bf63; }
.answer-d { background: #8cd94d; }

.answer-option.selected {
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
}

.answer-option.correct {
    background: var(--green) !important;
    color: white;
}

.answer-option.incorrect {
    background: var(--red) !important;
    color: white;
}

/* PLAYER HEALTH */
.player-health-section {
    padding: 20px;
    background: var(--bg-panel);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.health-container {
    flex: 1;
    max-width: 400px;
}

.health-bar {
    height: 25px;
    background: rgba(0, 0, 0, 0.1);
    border: 3px solid var(--border);
    overflow: hidden;
    margin-bottom: 8px;
}

.health-fill {
    height: 100%;
    background: var(--red);
    transition: width 0.5s ease;
}

.health-text {
    font-weight: 600;
    text-align: center;
    color: var(--accent);
}

.flasks {
    display: flex;
    gap: 10px;
}

.flask {
    width: 50px;
    height: 70px;
    background: var(--red);
    border: 3px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: white;
    position: relative;
    cursor: pointer;
}

.flask-count {
    position: absolute;
    bottom: 5px;
    right: 5px;
    background: var(--accent);
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.flask.disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* COMBAT LOG */
.combat-log {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    max-height: 200px;
    overflow-y: auto;
    background: var(--bg-main);
    border: 3px solid var(--border);
    padding: 15px;
    z-index: 1000;
    display: none;
}

.combat-log.show {
    display: block;
}

.log-entry {
    padding: 8px;
    border-bottom: 1px solid var(--border);
    font-size: 12px;
    margin-bottom: 5px;
}

.log-entry.damage { color: var(--red); }
.log-entry.heal { color: var(--green); }
.log-entry.crit { color: var(--orange); font-weight: bold; }
.log-entry.info { color: var(--blue); }

/* MODALS */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.modal.active {
    display: flex;
}

.modal-content {
    background-color: var(--bg-main);
    border-radius: 0;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    border: 3px solid var(--border);
}

.modal-header {
    padding: 15px;
    border-bottom: 3px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--bg-panel);
}

.modal-header h3 {
    margin: 0;
    font-size: 1.2rem;
}

.modal-body {
    padding: 20px;
    text-align: center;
}

.close-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--border);
    font-weight: bold;
}

.btn {
    border: 2px solid var(--border);
    background: var(--bg-main);
    padding: 10px 20px;
    text-align: center;
    font-weight: 600;
    cursor: pointer;
    margin: 5px;
    font-size: 14px;
}

.btn:hover {
    background: var(--tab-active);
}

.btn-primary {
    background: var(--accent);
    color: white;
}

.btn-primary:hover {
    background: #333;
}

.btn-success {
    background: var(--green);
    color: white;
}

.btn-danger {
    background: var(--red);
    color: white;
}

/* ANIMATIONS */
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.shake {
    animation: shake 0.5s ease;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.pulse {
    animation: pulse 0.5s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.fade-in {
    animation: fadeIn 0.3s ease;
}

/* RESPONSIVE */
@media (max-width: 768px) {
    .battle-grid {
        grid-template-columns: 1fr;
        gap: 20px;
    }
    
    .answers-section {
        grid-template-columns: 1fr;
    }
    
    .top-bar {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .player-health-section {
        flex-direction: column;
        gap: 15px;
        align-items: center;
    }
    
    .health-container {
        max-width: 100%;
    }
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
<div class="app">
    <!-- TOP BAR -->
    <div class="top-bar">
        <div class="profile">
            <div class="pfp" id="player-avatar">
                <i class="fas fa-user"></i>
            </div>
            <div class="profile-info">
                <div style="font-weight: 700;">HIGH SCORE: <span id="player-highscore">-</span></div>
                <div>NAME: <span id="player-name">-</span></div>
                <div>POWER: <span id="player-power">-</span></div>
            </div>
        </div>
        
        <div class="stage-display">
            <div class="stage-main" id="current-stage">STAGE -</div>
            <div class="stage-sub" id="stage-level">LEVEL -</div>
        </div>
        
        <div class="gold-display">
            <i class="fas fa-coins"></i> GOLD<br>
            <span id="gold-amount">-</span>
        </div>
    </div>

    <!-- BATTLE AREA -->
    <div class="battle-area">
        <div class="monster-header">
            <div class="monster-name" id="monster-name">-</div>
            <div class="monster-category" id="monster-category">-</div>
        </div>
        
        <div class="monster-hp-container">
            <div class="hp-bar">
                <div class="hp-fill" id="monster-hp-bar" style="width: 100%"></div>
            </div>
            <div class="hp-text" id="monster-hp-text">HP: - / -</div>
        </div>
        
        <div class="battle-grid">
            <!-- PLAYER PANEL -->
            <div class="player-panel">
                <div class="panel-box difficulty" id="difficulty">-</div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-damage">-</div>
                    <div class="stat-label">DAMAGE</div>
                </div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-defense">-</div>
                    <div class="stat-label">DEFENSE</div>
                </div>
                <div class="panel-box player-stat">
                    <div class="stat-value" id="player-crit">-</div>
                    <div class="stat-label">CRIT CHANCE</div>
                </div>
            </div>
            
            <!-- MONSTER DISPLAY -->
            <div class="monster-display">
                <div class="monster-image" id="monster-image">
                    <i class="fas fa-question"></i>
                </div>
            </div>
            
            <!-- TIMER -->
            <div class="timer-container">
                <div class="timer" id="timer">
                    <span id="timer-seconds">-</span>
                    <div class="timer-ring" id="timer-ring"></div>
                </div>
                <div class="timer-text" id="timer-text">SECONDS REMAINING</div>
            </div>
        </div>
    </div>

    <!-- QUESTION SECTION -->
    <div class="question-section">
        <div class="question-header">
            <div class="question-category" id="question-category">-</div>
            <div class="question-difficulty" id="question-difficulty">-</div>
        </div>
        <div class="question-box" id="question-text">
            -
        </div>
        <div class="question-image" id="question-image"></div>
    </div>

    <!-- ANSWERS -->
    <div class="answers-section" id="answers-container">
        <div class="answer-option answer-a" data-index="0">
            <div class="option-label">A</div>
            <div class="answer-text" id="answer-text-0">-</div>
            <div class="answer-image" id="answer-image-0"></div>
        </div>
        <div class="answer-option answer-b" data-index="1">
            <div class="option-label">B</div>
            <div class="answer-text" id="answer-text-1">-</div>
            <div class="answer-image" id="answer-image-1"></div>
        </div>
        <div class="answer-option answer-c" data-index="2">
            <div class="option-label">C</div>
            <div class="answer-text" id="answer-text-2">-</div>
            <div class="answer-image" id="answer-image-2"></div>
        </div>
        <div class="answer-option answer-d" data-index="3">
            <div class="option-label">D</div>
            <div class="answer-text" id="answer-text-3">-</div>
            <div class="answer-image" id="answer-image-3"></div>
        </div>
    </div>

    <!-- PLAYER HEALTH -->
    <div class="player-health-section">
        <div class="health-container">
            <div class="health-bar">
                <div class="health-fill" id="player-hp-bar" style="width: 100%"></div>
            </div>
            <div class="health-text" id="player-hp-text">HEALTH: - / -</div>
        </div>
        
        <div class="flasks">
            <div class="flask" id="health-flask" onclick="useHealthFlask()">
                <i class="fas fa-flask"></i>
                <div class="flask-count" id="flask-count">-</div>
            </div>
            <div class="flask" onclick="toggleCombatLog()" style="background: var(--blue);">
                <i class="fas fa-scroll"></i>
            </div>
        </div>
    </div>
</div>

<!-- COMBAT LOG -->
<div class="combat-log" id="combat-log">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h4 style="margin: 0;">Combat Log</h4>
        <button class="btn" onclick="clearCombatLog()" style="font-size: 10px; padding: 4px 8px;">Clear</button>
    </div>
    <div id="log-entries"></div>
</div>

<!-- RESULT MODAL -->
<div class="modal" id="result-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="result-title">-</h3>
            <button class="close-btn" onclick="closeResultModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div id="result-content">
                <div class="loading">-</div>
            </div>
        </div>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div class="modal" id="gameover-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--red);">GAME OVER</h3>
            <button class="close-btn" onclick="closeGameOverModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-skull-crossbones" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4>You have been defeated!</h4>
                <p id="gameover-details">-</p>
                <p id="gameover-gold">-</p>
                <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="returnToLobby()">
                        <i class="fas fa-home"></i> LOBBY
                    </button>
                    <button class="btn btn-success" onclick="restartRun()">
                        <i class="fas fa-redo"></i> RETRY
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- STAGE CLEAR MODAL -->
<div class="modal" id="stageclear-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--green);">STAGE CLEAR!</h3>
            <button class="close-btn" onclick="closeStageClearModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-trophy" style="font-size: 64px; color: var(--yellow); margin-bottom: 20px;"></i>
                <h4>Monster Defeated!</h4>
                <p id="stageclear-details">-</p>
                <p id="stageclear-reward">-</p>
                <p id="stageclear-streak">-</p>
                <div style="margin-top: 30px;">
                    <button class="btn btn-success" onclick="nextStage()">
                        <i class="fas fa-forward"></i> NEXT STAGE
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ERROR MODAL -->
<div class="modal" id="error-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 style="color: var(--red);">ERROR</h3>
            <button class="close-btn" onclick="closeErrorModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 20px;">
                <i class="fas fa-exclamation-triangle" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4 id="error-title">Game Setup Required</h4>
                <p id="error-message">No game data found. Please set up the game first.</p>
                <div style="margin-top: 30px;">
                    <button class="btn btn-primary" onclick="goToAdmin()">
                        <i class="fas fa-cog"></i> GO TO ADMIN PANEL
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
// Import Supabase client
import { supabase } from './supabase.js';

console.log('RPG Battle - Supabase client loaded');

// Game state
let gameState = {
    currentRun: null,
    playerStats: null,
    currentMonster: null,
    currentQuestion: null,
    questionOptions: [],
    selectedAnswer: null,
    timerInterval: null,
    timeLeft: 30,
    maxTime: 30,
    isAnswering: false,
    combatLog: [],
    healthFlasks: 3,
    streak: 0,
    goldEarned: 0,
    currentUser: null,
    monsterQuestions: [],      // All questions assigned to current monster
    currentQuestionIndex: 0    // Current question index in monsterQuestions array
};

// Initialize game
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Initializing RPG Battle...');
    
    // Load game data
    await loadGameData();
    
    // Setup event listeners
    setupEventListeners();
});

// Load game data from Supabase
async function loadGameData() {
    try {
        // Get current user
        const { data: users, error: usersError } = await supabase
            .from('users')
            .select('*')
            .order('created_at', { ascending: true })
            .limit(1);
        
        if (usersError) {
            console.error('Error loading users:', usersError);
            showError('Database Error', 'Could not load user data. Please check database connection.');
            return;
        }
        
        if (!users || users.length === 0) {
            showError('No User Found', 'Please create a user in the admin panel first.');
            return;
        }
        
        gameState.currentUser = users[0];
        
        // Update player info
        document.getElementById('player-name').textContent = gameState.currentUser.username || 'Player';
        document.getElementById('player-highscore').textContent = gameState.currentUser.highest_stage || 1;
        document.getElementById('gold-amount').textContent = gameState.currentUser.gold || 0;
        
        // Get player stats
        const { data: stats, error: statsError } = await supabase
            .from('player_stats')
            .select('*')
            .eq('user_id', gameState.currentUser.id)
            .single();
        
        if (statsError) {
            console.error('Error loading player stats:', statsError);
            showError('Missing Player Stats', 'Please set up player stats in the admin panel.');
            return;
        }
        
        if (stats) {
            gameState.playerStats = stats;
        } else {
            showError('Missing Player Stats', 'Please set up player stats in the admin panel.');
            return;
        }
        
        // Get current run
        const { data: runs, error: runsError } = await supabase
            .from('runs')
            .select(`
                *,
                monster:current_monster (*)
            `)
            .eq('user_id', gameState.currentUser.id)
            .order('created_at', { ascending: false })
            .limit(1);
        
        if (runsError) {
            console.error('Error loading runs:', runsError);
            showError('Database Error', 'Could not load game data.');
            return;
        }
        
        if (runs && runs.length > 0) {
            gameState.currentRun = runs[0];
            
            // Load monster if available
            if (gameState.currentRun.current_monster) {
                await loadMonster(gameState.currentRun.current_monster);
            } else {
                // Get monster for current stage
                await loadMonsterForStage(gameState.currentRun.current_stage);
            }
            
            // Check if monsters exist
            if (!gameState.currentMonster) {
                showError('No Monsters', 'Please add monsters to the database in the admin panel.');
                return;
            }
            
            updateRunDisplay();
            
            // Load monster-specific questions
            await loadMonsterQuestions(gameState.currentMonster.id);
            
            // Load first question
            await loadQuestion();
            
            // Start the game timer
            startTimer();
            
        } else {
            // No active run, create one
            await createNewRun();
        }
        
    } catch (error) {
        console.error('Error loading game data:', error);
        showError('Game Error', 'Failed to load game. Please try again.');
    }
}

// Create new run
async function createNewRun() {
    try {
        // Check if monsters exist
        const { data: monsters, error: monstersError } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', 1)
            .limit(1);
        
        if (monstersError) throw monstersError;
        
        if (!monsters || monsters.length === 0) {
            showError('No Monsters', 'Please add monsters to the database in the admin panel.');
            return;
        }
        
        const monster = monsters[0];
        const playerHP = gameState.playerStats?.base_hp || 100;
        
        // Create run
        const { data: run, error: runError } = await supabase
            .from('runs')
            .insert([{
                user_id: gameState.currentUser.id,
                current_stage: 1,
                current_monster: monster.id,
                player_hp: playerHP,
                monster_hp: monster.hp,
                streak: 0,
                started_at: new Date().toISOString()
            }])
            .select()
            .single();
        
        if (runError) throw runError;
        
        gameState.currentRun = run;
        await loadMonster(monster.id);
        updateRunDisplay();
        
        // Load monster-specific questions
        await loadMonsterQuestions(monster.id);
        
        addToCombatLog('New run started!', 'info');
        
        // Load first question
        await loadQuestion();
        
        // Start timer
        startTimer();
        
    } catch (error) {
        console.error('Error creating new run:', error);
        showError('Run Creation Failed', 'Could not start new game. Please try again.');
    }
}

// Load monster data
async function loadMonster(monsterId) {
    try {
        const { data: monster, error } = await supabase
            .from('monsters')
            .select('*')
            .eq('id', monsterId)
            .single();
        
        if (error) throw error;
        
        gameState.currentMonster = monster;
        updateMonsterDisplay();
        
    } catch (error) {
        console.error('Error loading monster:', error);
        gameState.currentMonster = null;
    }
}

// Load monster-specific questions
async function loadMonsterQuestions(monsterId) {
    try {
        // Get all questions assigned to this monster
        const { data: monsterQuestions, error } = await supabase
            .from('monster_questions')
            .select(`
                question_order,
                questions (*)
            `)
            .eq('monster_id', monsterId)
            .order('question_order', { ascending: true });
        
        if (error) throw error;
        
        if (monsterQuestions && monsterQuestions.length > 0) {
            // Extract the questions from the result
            gameState.monsterQuestions = monsterQuestions.map(mq => ({
                ...mq.questions,
                question_order: mq.question_order
            }));
            gameState.currentQuestionIndex = 0;
            console.log(`Loaded ${gameState.monsterQuestions.length} questions for monster`);
        } else {
            // No specific questions assigned - use any questions from monster category
            console.log('No specific questions assigned to monster, will use category-based questions');
            gameState.monsterQuestions = [];
        }
        
    } catch (error) {
        console.error('Error loading monster questions:', error);
        gameState.monsterQuestions = [];
    }
}

// Load monster for current stage
async function loadMonsterForStage(stage) {
    try {
        const { data: monsters, error } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', stage)
            .limit(1);
        
        if (error) throw error;
        
        if (monsters && monsters.length > 0) {
            gameState.currentMonster = monsters[0];
            updateMonsterDisplay();
            
            // Load monster-specific questions
            await loadMonsterQuestions(gameState.currentMonster.id);
        }
        
    } catch (error) {
        console.error('Error loading monster for stage:', error);
    }
}

// Load question from database
async function loadQuestion() {
    try {
        // Reset selection
        gameState.selectedAnswer = null;
        gameState.isAnswering = false;
        
        // Clear previous selections
        document.querySelectorAll('.answer-option').forEach(option => {
            option.classList.remove('selected', 'correct', 'incorrect');
        });
        
        let question = null;
        
        // Check if we have monster-specific questions
        if (gameState.monsterQuestions && gameState.monsterQuestions.length > 0) {
            // Use monster-specific questions in order
            question = gameState.monsterQuestions[gameState.currentQuestionIndex];
            
            // Move to next question (loop back if at end)
            gameState.currentQuestionIndex = (gameState.currentQuestionIndex + 1) % gameState.monsterQuestions.length;
            
            console.log(`Using monster-specific question ${gameState.currentQuestionIndex}/${gameState.monsterQuestions.length}`);
            
        } else {
            // Fallback: Get random question from monster's category
            console.log('Using fallback: random question from category');
            
            // Check if questions exist
            const { data: questionsCount, error: countError } = await supabase
                .from('questions')
                .select('*', { count: 'exact', head: true });
            
            if (countError) throw countError;
            
            if (!questionsCount || questionsCount === 0) {
                showError('No Questions', 'Please add questions to the database in the admin panel.');
                return;
            }
            
            // Get random question
            let query = supabase
                .from('questions')
                .select('*');
            
            // Filter by monster category if available
            if (gameState.currentMonster?.category) {
                query = query.eq('category', gameState.currentMonster.category);
            }
            
            const { data: questions, error } = await query;
            
            if (error) throw error;
            
            if (!questions || questions.length === 0) {
                // Fallback to any question
                const { data: allQuestions, error: allError } = await supabase
                    .from('questions')
                    .select('*');
                
                if (allError) throw allError;
                
                if (!allQuestions || allQuestions.length === 0) {
                    addToCombatLog('No questions available!', 'error');
                    return;
                }
                
                const randomIndex = Math.floor(Math.random() * allQuestions.length);
                question = allQuestions[randomIndex];
            } else {
                const randomIndex = Math.floor(Math.random() * questions.length);
                question = questions[randomIndex];
            }
        }
        
        if (!question) {
            addToCombatLog('No question available!', 'error');
            return;
        }
        
        gameState.currentQuestion = question;
        
        // Get question options
        const { data: options, error: optionsError } = await supabase
            .from('question_options')
            .select('*')
            .eq('question_id', gameState.currentQuestion.id);
        
        if (optionsError) throw optionsError;
        
        gameState.questionOptions = options || [];
        
        // Check if we have enough options
        if (gameState.questionOptions.length < 2) {
            addToCombatLog('Question has insufficient options!', 'error');
            return;
        }
        
        // Shuffle options to randomize positions (keep track of correct answer)
        shuffleOptions();
        
        // Update display
        updateQuestionDisplay();
        
        // Set timer based on question
        gameState.maxTime = gameState.currentQuestion.timer_seconds || 30;
        gameState.timeLeft = gameState.maxTime;
        updateTimer();
        
        // Reset timer ring
        document.getElementById('timer-ring').style.transform = 'rotate(0deg)';
        
        addToCombatLog('New question loaded: ' + gameState.currentQuestion.category, 'info');
        
    } catch (error) {
        console.error('Error loading question:', error);
        addToCombatLog('Failed to load question: ' + error.message, 'error');
    }
}

// Shuffle question options while keeping track of correct answer
function shuffleOptions() {
    if (!gameState.questionOptions || gameState.questionOptions.length < 2) return;
    
    // Create array of indices
    const indices = Array.from({ length: gameState.questionOptions.length }, (_, i) => i);
    
    // Fisher-Yates shuffle
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    
    // Reorder options based on shuffled indices
    const shuffledOptions = indices.map(i => gameState.questionOptions[i]);
    gameState.questionOptions = shuffledOptions;
}

// Update player stats display
function updatePlayerStats() {
    if (!gameState.playerStats) return;
    
    const baseDamage = gameState.playerStats.base_damage || 10;
    const baseDefense = gameState.playerStats.base_defense || 5;
    const critChance = gameState.playerStats.crit_chance || 0.05;
    
    document.getElementById('player-damage').textContent = baseDamage;
    document.getElementById('player-defense').textContent = baseDefense;
    document.getElementById('player-crit').textContent = `${(critChance * 100).toFixed(1)}%`;
    
    // Calculate power level
    const power = baseDamage + baseDefense + (critChance * 100);
    document.getElementById('player-power').textContent = Math.round(power);
}

// Update run display
function updateRunDisplay() {
    if (!gameState.currentRun) return;
    
    document.getElementById('current-stage').textContent = `STAGE ${gameState.currentRun.current_stage}`;
    document.getElementById('stage-level').textContent = `LEVEL ${gameState.currentRun.current_stage}`;
    
    // Update player HP
    const playerHP = gameState.currentRun.player_hp;
    const maxHP = gameState.playerStats?.base_hp || 100;
    const hpPercent = (playerHP / maxHP) * 100;
    
    document.getElementById('player-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('player-hp-text').textContent = `HEALTH: ${playerHP} / ${maxHP}`;
    
    // Update streak
    gameState.streak = gameState.currentRun.streak || 0;
    
    // Update player stats
    updatePlayerStats();
}

// Update monster display
function updateMonsterDisplay() {
    if (!gameState.currentMonster) return;
    
    document.getElementById('monster-name').textContent = gameState.currentMonster.name;
    document.getElementById('monster-category').textContent = gameState.currentMonster.category || 'MONSTER';
    
    // Update monster HP
    const monsterHP = gameState.currentRun?.monster_hp || gameState.currentMonster.hp;
    const maxHP = gameState.currentMonster.hp;
    const hpPercent = (monsterHP / maxHP) * 100;
    
    document.getElementById('monster-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('monster-hp-text').textContent = `HP: ${monsterHP} / ${maxHP}`;
    
    // Update difficulty
    const stage = gameState.currentRun?.current_stage || 1;
    const difficulty = stage <= 3 ? 'EASY' : stage <= 6 ? 'MEDIUM' : stage <= 10 ? 'HARD' : 'EXPERT';
    document.getElementById('difficulty').textContent = difficulty;
    
    // Update monster image
    const monsterImage = document.getElementById('monster-image');
    if (gameState.currentMonster.image_url) {
        monsterImage.innerHTML = `<img src="${gameState.currentMonster.image_url}" alt="${gameState.currentMonster.name}" onerror="this.parentElement.innerHTML='<i class=\\'fas fa-dragon\\'></i>'">`;
    } else {
        monsterImage.innerHTML = '<i class="fas fa-dragon"></i>';
    }
}

// Update question display
function updateQuestionDisplay() {
    if (!gameState.currentQuestion) return;
    
    document.getElementById('question-text').textContent = gameState.currentQuestion.question_text;
    document.getElementById('question-category').textContent = gameState.currentQuestion.category || 'GENERAL';
    document.getElementById('question-difficulty').textContent = gameState.currentQuestion.difficulty || 'MEDIUM';
    
    // Update question image
    const questionImage = document.getElementById('question-image');
    if (gameState.currentQuestion.image_url) {
        questionImage.src = gameState.currentQuestion.image_url;
        questionImage.alt = gameState.currentQuestion.question_text;
        questionImage.classList.add('show');
    } else {
        questionImage.classList.remove('show');
    }
    
    // Update answer options (only show up to 4 options)
    for (let i = 0; i < 4; i++) {
        const option = gameState.questionOptions[i];
        const answerText = document.getElementById(`answer-text-${i}`);
        const answerImage = document.getElementById(`answer-image-${i}`);
        const answerOption = document.querySelector(`.answer-option[data-index="${i}"]`);
        
        if (option) {
            answerText.textContent = option.option_text;
            
            if (option.image_url) {
                answerImage.src = option.image_url;
                answerImage.alt = option.option_text;
                answerImage.classList.add('show');
            } else {
                answerImage.classList.remove('show');
            }
            
            answerOption.style.display = 'flex';
        } else {
            answerOption.style.display = 'none';
        }
    }
}

// Setup event listeners
function setupEventListeners() {
    // Answer selection
    document.querySelectorAll('.answer-option').forEach(option => {
        option.addEventListener('click', function() {
            if (gameState.isAnswering) return;
            
            const index = parseInt(this.getAttribute('data-index'));
            selectAnswer(index);
        });
    });
}

// Select answer
function selectAnswer(index) {
    if (gameState.isAnswering) return;
    
    // Clear previous selection
    document.querySelectorAll('.answer-option').forEach(option => {
        option.classList.remove('selected');
    });
    
    // Mark selected
    const selectedOption = document.querySelector(`.answer-option[data-index="${index}"]`);
    selectedOption.classList.add('selected');
    gameState.selectedAnswer = index;
    gameState.isAnswering = true;
    
    // Clear timer
    clearInterval(gameState.timerInterval);
    
    // Check answer
    checkAnswer(index);
}

// Check if answer is correct
async function checkAnswer(selectedIndex) {
    const option = gameState.questionOptions[selectedIndex];
    const isCorrect = option?.is_correct || false;
    
    // Mark correct/incorrect
    document.querySelectorAll('.answer-option').forEach(optionEl => {
        const optionIndex = parseInt(optionEl.getAttribute('data-index'));
        const optionData = gameState.questionOptions[optionIndex];
        
        if (optionData?.is_correct) {
            optionEl.classList.add('correct');
        } else if (optionIndex === selectedIndex) {
            optionEl.classList.add('incorrect');
        }
    });
    
    // Process combat
    await processCombat(isCorrect);
    
    // Show result
    showResult(isCorrect, option?.option_text);
}

// Process combat based on answer
async function processCombat(isCorrect) {
    try {
        if (!gameState.currentRun || !gameState.currentMonster) return;
        
        let damageToMonster = 0;
        let damageToPlayer = 0;
        let goldEarned = 0;
        
        if (isCorrect) {
            // Player hits monster
            const baseDamage = gameState.playerStats?.base_damage || 10;
            const critChance = gameState.playerStats?.crit_chance || 0.05;
            const isCrit = Math.random() < critChance;
            
            damageToMonster = baseDamage;
            
            // Apply crit
            if (isCrit) {
                damageToMonster *= 2;
                addToCombatLog(`CRITICAL HIT! ${damageToMonster} damage!`, 'crit');
            } else {
                addToCombatLog(`Hit monster for ${damageToMonster} damage`, 'damage');
            }
            
            // Apply monster defense
            const monsterDefense = gameState.currentMonster.defense || 0;
            damageToMonster = Math.max(1, damageToMonster - monsterDefense);
            
            // Update monster HP
            let newMonsterHP = gameState.currentRun.monster_hp - damageToMonster;
            if (newMonsterHP < 0) newMonsterHP = 0;
            
            // Monster attacks player (reduced damage on correct answer)
            const monsterDamage = Math.floor((gameState.currentMonster.damage || 10) * 0.3);
            const playerDefense = gameState.playerStats?.base_defense || 5;
            damageToPlayer = Math.max(1, monsterDamage - playerDefense);
            
            addToCombatLog(`Monster hits back for ${damageToPlayer} damage`, 'damage');
            
            // Update player HP
            let newPlayerHP = gameState.currentRun.player_hp - damageToPlayer;
            
            // Gold reward - use monster's gold_reward field
            goldEarned = gameState.currentMonster.gold_reward || Math.floor(gameState.currentMonster.stage * 10);
            gameState.goldEarned += goldEarned;
            
            // Increase streak
            gameState.streak++;
            
            // Update run in database
            const { error: updateError } = await supabase
                .from('runs')
                .update({
                    monster_hp: newMonsterHP,
                    player_hp: newPlayerHP,
                    streak: gameState.streak
                })
                .eq('id', gameState.currentRun.id);
            
            if (updateError) throw updateError;
            
            // Update local state
            gameState.currentRun.monster_hp = newMonsterHP;
            gameState.currentRun.player_hp = newPlayerHP;
            gameState.currentRun.streak = gameState.streak;
            
            // Check if monster is defeated
            if (newMonsterHP <= 0) {
                setTimeout(() => {
                    showStageClear(goldEarned);
                }, 1500);
            } else {
                setTimeout(() => {
                    loadQuestion();
                    startTimer();
                }, 2000);
            }
            
        } else {
            // Wrong answer - monster hits harder
            const monsterDamage = gameState.currentMonster.damage || 10;
            const playerDefense = gameState.playerStats?.base_defense || 5;
            damageToPlayer = Math.max(5, monsterDamage - playerDefense);
            
            addToCombatLog(`Wrong answer! Monster hits for ${damageToPlayer} damage`, 'damage');
            
            // Reset streak
            gameState.streak = 0;
            
            // Update player HP
            let newPlayerHP = gameState.currentRun.player_hp - damageToPlayer;
            
            // Update run in database
            const { error: updateError } = await supabase
                .from('runs')
                .update({
                    player_hp: newPlayerHP,
                    streak: 0
                })
                .eq('id', gameState.currentRun.id);
            
            if (updateError) throw updateError;
            
            // Update local state
            gameState.currentRun.player_hp = newPlayerHP;
            gameState.currentRun.streak = 0;
            
            // Check if player is dead
            if (newPlayerHP <= 0) {
                setTimeout(() => {
                    showGameOver();
                }, 1500);
            } else {
                setTimeout(() => {
                    loadQuestion();
                    startTimer();
                }, 2000);
            }
        }
        
        // Update UI
        updateRunDisplay();
        updateMonsterDisplay();
        
    } catch (error) {
        console.error('Error processing combat:', error);
        addToCombatLog('Combat error: ' + error.message, 'error');
    }
}

// Start timer
function startTimer() {
    // Clear existing timer
    clearInterval(gameState.timerInterval);
    
    // Reset time
    gameState.timeLeft = gameState.maxTime;
    updateTimer();
    
    // Start countdown
    gameState.timerInterval = setInterval(() => {
        gameState.timeLeft--;
        updateTimer();
        
        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timerInterval);
            timeOut();
        }
    }, 1000);
}

// Update timer display
function updateTimer() {
    document.getElementById('timer-seconds').textContent = gameState.timeLeft;
    
    // Update timer ring
    const progress = (gameState.timeLeft / gameState.maxTime) * 360;
    document.getElementById('timer-ring').style.transform = `rotate(${progress}deg)`;
    
    // Update text color based on time
    if (gameState.timeLeft <= 10) {
        document.getElementById('timer-seconds').style.color = 'var(--red)';
    } else if (gameState.timeLeft <= 20) {
        document.getElementById('timer-seconds').style.color = 'var(--orange)';
    } else {
        document.getElementById('timer-seconds').style.color = 'var(--accent)';
    }
}

// Time out handler
function timeOut() {
    if (gameState.isAnswering) return;
    
    addToCombatLog('Time ran out!', 'info');
    
    // Process as wrong answer
    const randomAnswer = Math.floor(Math.random() * Math.min(4, gameState.questionOptions.length));
    selectAnswer(randomAnswer);
}

// Show result
function showResult(isCorrect, answerText) {
    const modal = document.getElementById('result-modal');
    const title = document.getElementById('result-title');
    const content = document.getElementById('result-content');
    
    if (isCorrect) {
        title.textContent = 'CORRECT!';
        title.style.color = 'var(--green)';
        content.innerHTML = `
            <div style="text-align: center;">
                <i class="fas fa-check-circle" style="font-size: 64px; color: var(--green); margin-bottom: 20px;"></i>
                <h4>Well done!</h4>
                <p>Your answer: <strong>${answerText || 'Correct'}</strong></p>
                <p>Streak: <strong>${gameState.streak}</strong></p>
            </div>
        `;
    } else {
        title.textContent = 'WRONG!';
        title.style.color = 'var(--red)';
        content.innerHTML = `
            <div style="text-align: center;">
                <i class="fas fa-times-circle" style="font-size: 64px; color: var(--red); margin-bottom: 20px;"></i>
                <h4>Incorrect answer</h4>
                <p>Your answer: <strong>${answerText || 'Wrong'}</strong></p>
                <p>The correct answer was highlighted.</p>
                <p>Streak lost!</p>
            </div>
        `;
    }
    
    modal.classList.add('active');
}

// Close result modal
function closeResultModal() {
    document.getElementById('result-modal').classList.remove('active');
}

// Show stage clear
function showStageClear(goldEarned) {
    const modal = document.getElementById('stageclear-modal');
    
    document.getElementById('stageclear-details').textContent = 
        `Stage ${gameState.currentRun.current_stage} cleared!`;
    document.getElementById('stageclear-reward').textContent = 
        `Reward: ${goldEarned} Gold`;
    document.getElementById('stageclear-streak').textContent = 
        `Streak: ${gameState.streak}`;
    
    modal.classList.add('active');
}

// Close stage clear modal
function closeStageClearModal() {
    document.getElementById('stageclear-modal').classList.remove('active');
}

// Show game over
async function showGameOver() {
    try {
        // Update user gold
        const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
        
        await supabase
            .from('users')
            .update({ 
                gold: newGold,
                highest_stage: Math.max(gameState.currentUser.highest_stage || 0, gameState.currentRun.current_stage)
            })
            .eq('id', gameState.currentUser.id);
        
        // Delete the run
        await supabase
            .from('runs')
            .delete()
            .eq('id', gameState.currentRun.id);
        
        const modal = document.getElementById('gameover-modal');
        
        document.getElementById('gameover-details').textContent = 
            `Stage reached: ${gameState.currentRun.current_stage}`;
        document.getElementById('gameover-gold').textContent = 
            `Gold earned: ${gameState.goldEarned}`;
        
        modal.classList.add('active');
        
    } catch (error) {
        console.error('Error in game over:', error);
    }
}

// Close game over modal
function closeGameOverModal() {
    document.getElementById('gameover-modal').classList.remove('active');
}

// Show error modal
function showError(title, message) {
    document.getElementById('error-title').textContent = title;
    document.getElementById('error-message').textContent = message;
    document.getElementById('error-modal').classList.add('active');
}

// Close error modal
function closeErrorModal() {
    document.getElementById('error-modal').classList.remove('active');
}

// Go to admin panel
function goToAdmin() {
    window.location.href = 'adminside.html';
}

// Next stage
async function nextStage() {
    try {
        const nextStage = gameState.currentRun.current_stage + 1;
        
        // Get monster for next stage
        const { data: monsters, error: monstersError } = await supabase
            .from('monsters')
            .select('*')
            .eq('stage', nextStage)
            .limit(1);
        
        if (monstersError) throw monstersError;
        
        if (!monsters || monsters.length === 0) {
            // No more stages - victory!
            addToCombatLog('No more monsters! You win!', 'info');
            
            // Update user with final gold
            const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
            
            await supabase
                .from('users')
                .update({ 
                    gold: newGold,
                    highest_stage: Math.max(gameState.currentUser.highest_stage || 0, gameState.currentRun.current_stage)
                })
                .eq('id', gameState.currentUser.id);
            
            // Delete run
            await supabase
                .from('runs')
                .delete()
                .eq('id', gameState.currentRun.id);
            
            alert('Congratulations! You have completed all stages!');
            window.location.href = 'lobby.html';
            return;
        }
        
        const monster = monsters[0];
        
        // Update run to next stage
        const { error: updateError } = await supabase
            .from('runs')
            .update({
                current_stage: nextStage,
                current_monster: monster.id,
                monster_hp: monster.hp
            })
            .eq('id', gameState.currentRun.id);
        
        if (updateError) throw updateError;
        
        // Update local state
        gameState.currentRun.current_stage = nextStage;
        gameState.currentRun.current_monster = monster.id;
        gameState.currentRun.monster_hp = monster.hp;
        
        // Update gold in user
        const newGold = (gameState.currentUser.gold || 0) + gameState.goldEarned;
        
        await supabase
            .from('users')
            .update({ gold: newGold })
            .eq('id', gameState.currentUser.id);
        
        document.getElementById('gold-amount').textContent = newGold;
        gameState.currentUser.gold = newGold;
        gameState.goldEarned = 0;
        
        // Reset question cycling
        gameState.currentQuestionIndex = 0;
        
        closeStageClearModal();
        await loadMonster(monster.id);
        await loadMonsterQuestions(monster.id);
        await loadQuestion();
        startTimer();
        
        addToCombatLog(`Advanced to stage ${nextStage}!`, 'info');
        
    } catch (error) {
        console.error('Error advancing to next stage:', error);
        addToCombatLog('Failed to advance: ' + error.message, 'error');
    }
}

// Return to lobby
function returnToLobby() {
    closeGameOverModal();
    window.location.href = 'lobby.html';
}

// Restart run
async function restartRun() {
    try {
        // Delete current run
        await supabase
            .from('runs')
            .delete()
            .eq('id', gameState.currentRun.id);
        
        closeGameOverModal();
        await createNewRun();
        
    } catch (error) {
        console.error('Error restarting run:', error);
    }
}

// Use health flask
function useHealthFlask() {
    if (gameState.healthFlasks <= 0 || !gameState.currentRun) return;
    
    if (gameState.currentRun.player_hp >= (gameState.playerStats?.base_hp || 100)) {
        addToCombatLog('Already at full health!', 'info');
        return;
    }
    
    gameState.healthFlasks--;
    
    // Heal 50% of max HP
    const maxHP = gameState.playerStats?.base_hp || 100;
    const healAmount = Math.floor(maxHP * 0.5);
    const newHP = Math.min(maxHP, gameState.currentRun.player_hp + healAmount);
    
    // Update run
    supabase
        .from('runs')
        .update({ player_hp: newHP })
        .eq('id', gameState.currentRun.id)
        .then(() => {
            gameState.currentRun.player_hp = newHP;
            updateRunDisplay();
            addToCombatLog(`Used health flask! Healed ${healAmount} HP`, 'heal');
            
            // Update flask count
            document.getElementById('flask-count').textContent = gameState.healthFlasks;
            
            if (gameState.healthFlasks <= 0) {
                document.getElementById('health-flask').classList.add('disabled');
            }
        });
}

// Toggle combat log
function toggleCombatLog() {
    const log = document.getElementById('combat-log');
    log.classList.toggle('show');
}

// Clear combat log
function clearCombatLog() {
    gameState.combatLog = [];
    document.getElementById('log-entries').innerHTML = '';
}

// Add to combat log
function addToCombatLog(message, type = 'info') {
    gameState.combatLog.push({ message, type, timestamp: new Date() });
    
    // Keep only last 10 entries
    if (gameState.combatLog.length > 10) {
        gameState.combatLog.shift();
    }
    
    // Update display
    const logEntries = document.getElementById('log-entries');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}] ${message}`;
    
    logEntries.appendChild(entry);
    logEntries.scrollTop = logEntries.scrollHeight;
}

// Initialize health flask count
function initializeFlasks() {
    document.getElementById('flask-count').textContent = gameState.healthFlasks;
    if (gameState.healthFlasks <= 0) {
        document.getElementById('health-flask').classList.add('disabled');
    }
}

// Make functions globally available
window.useHealthFlask = useHealthFlask;
window.toggleCombatLog = toggleCombatLog;
window.clearCombatLog = clearCombatLog;
window.closeResultModal = closeResultModal;
window.closeStageClearModal = closeStageClearModal;
window.closeGameOverModal = closeGameOverModal;
window.returnToLobby = returnToLobby;
window.restartRun = restartRun;
window.nextStage = nextStage;
window.goToAdmin = goToAdmin;
window.closeErrorModal = closeErrorModal;

// Initialize flasks
initializeFlasks();
</script>
</body>
</html>